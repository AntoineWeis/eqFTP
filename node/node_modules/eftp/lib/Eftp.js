/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 2,
maxerr: 50, node: true */

"use strict";

var util = require('util'),
  EventEmitter = require('events').EventEmitter,
  fs = require('fs'),
  FTPClient = require('jsftp'),
  SSHClient = require('ssh2').Client,
  FileUtil = require('./FileUtil'),
  _ = require('lodash'),
  semver = require('semver');

if (semver.ltr(process.version.replace(/^[^d]/, ''), '0.10.30')) {
  console.log('Node version is lower than 0.10.30. Due to this we\'re fixing socket.pipe with socket.resume() method.');
  var once = require('once');
  var NOOP = function() { };
  /**
   * Depending on the number of parameters, returns the content of the specified
   * file or directly saves a file into the specified destination. In the latter
   * case, an optional callback can be provided, which will receive the error in
   * case the operation was not successful.
   *
   * @param {String} remotePath File to be retrieved from the FTP server
   * @param {Function|String} localPath Local path where we create the new file
   * @param {Function} [callback] Gets called on either success or failure
   */
  FTPClient.prototype.get = function(remotePath, localPath, callback) {
    var self = this;
    var finalCallback;

    if (typeof localPath === 'function') {
      finalCallback = once(localPath || NOOP);
    } else {
      callback = once(callback || NOOP);
      finalCallback = function(err, socket) {
        if (err) {
          return callback(err);
        }

        var writeStream = fs.createWriteStream(localPath);
        writeStream.on('error', callback);

        socket.on('readable', function() {
          self.emitProgress({
            filename: remotePath,
            action: 'get',
            socket: socket
          });
        });

        // This ensures that any expected outcome is handled. There is no
        // danger of the callback being executed several times, because it is
        // wrapped in `once`.
        socket.on('error', callback);
        socket.on('end', callback);
        socket.on('close', callback);

        socket.pipe(writeStream);
        socket.resume();
      };
    }

    this.getGetSocket(remotePath, finalCallback);
  };
}

function parsePasvList(data) {
  var list = data.split("\r\n"),
      arr = [],
      year = new Date().getFullYear(),
      i = 0,
      len = list.length;

  function getName(s, s1, s2) {
    var n = 1;
    while (true) {
      var t = "",
          i = 0;
      for (i = 0; i < n; i++) {
        t += " ";
      }
      t = s1 + t + s2;
      if (s.indexOf(t) > -1) {
        return s.substring(s.indexOf(t) + 1);
      }
      n++;
      if (n > 20) {
        break;
      }
    }
    return "";
  }

  for (i = 0; i < len; i++) {
    if (!list[i]) {
      continue;
    }
    var o = {type: 'f'},
        temp = list[i].split(/\s+/);
    if (list[i].substring(0, 1) === 'd') { o.type = 'd'; }
    o.size = parseInt(temp[4], 10);
    var dt = temp[5] + " " + temp[6] + " " + (temp[7].indexOf(":") > -1 ? year + " " + temp[7] + ":00 GMT+0000" : temp[7]);
    o.date = new Date(dt);
    if (temp.length === 9) {
      o.name = temp[8];
    } else {
      o.name = getName(list[i], temp[6], temp[7]);
    }
    o.str = list[i];
    arr.push(o);
  }
  return arr;
}

function EasyFTP() {
  if (!this instanceof EasyFTP) { throw "must 'new EasyFTP()'"; }
  EventEmitter.call(this);
}
util.inherits(EasyFTP, EventEmitter);

EasyFTP.prototype.init = function (config) {
  this.isConnect = false;
  this.isLoginFail = false;
  this.waitCount = 0;
  this.config = _.defaultsDeep(config, {
    host: 'localhost',
    port: 21,
    type: 'ftp',
    username: 'anonymous',
    password: 'anonymous@'
  });
  this.config.user = this.config.username;
  if (!this.config.type) {
    this.config.type = 'ftp';
  }
  if (this.config.type === 'sftp' && FileUtil.existSync(this.config.privateKey)) {
    this.config.privateKey = fs.readFileSync(this.config.privateKey);
  }
};

EasyFTP.prototype.connect = function (config) {
  var self = this;
  if (!config) {
    throw "must config param";
  }
  this.init(config);
  
  var events = {
    ready: function (err) {
      if (!err) {
        self.isConnect = true;
        self.emit('ready', self.client);
        console.log('!!!ready: ', arguments);
      }
    },
    close: function (err) {
      self.emit('close', err);
      self.close();
      console.log('!!!close: ', arguments);
    },
    error: function (err) {
      self.emit('error', err);
      self.close();
      console.log('!!!error: ', arguments);
    }
  };
  switch (this.config.type) {
  case 'sftp':
    this.client = new SSHClient();
    break;
  case 'ftp':
    this.client = new FTPClient({
      host: config.host,
      port: config.port || 21,
      user: config.username,
      pass: config.password
    });
    //this.client.on('connect', events.ready);
    this.client.on('timeout', events.close);
    this.client.on('error', events.error);
    this.client.auth(config.username, config.password, function (err, response) {
      if (err) {
        self.isLoginFail = true;
        events.error(err);
      } else {
        self.client.ls("/", function (err, list) {
          if (!err) {
            self.isPasv = false;
          } else {
            self.client.list("/", function (err, list) {
              if (!err) {
                self.isPasv = true;
              } else {
                events.error(err);
              }
            });
          }
        });
        events.ready(undefined);
      }
    });
    break;
  default:
    this.emit("error", new Error("Wrong protocol submitted"));
    break;
  }
};

EasyFTP.prototype.close = function () {
  try {
    this.client.end();
  } catch (e) {
  } finally { this.client = null; }
};

EasyFTP.prototype.getRealRemotePath = function (path) {
  var p = path;
  if (path.indexOf("/") !== 0) {
    var tempCurrentPath = this.currentPath;
    if (path.indexOf("./") === 0 && path.length > 2) {
      path = path.substring(2);
    }
    var upIdx = path.indexOf("../");
    while (upIdx === 0 && tempCurrentPath !== "/") {
      tempCurrentPath = tempCurrentPath.substring(0, tempCurrentPath.lastIndexOf("/"));
      path = path.substring(3);
      upIdx = path.indexOf("../");
    }
    if (tempCurrentPath === '/') {
      p = tempCurrentPath + path;
    } else {
      p = tempCurrentPath + "/" + path;
    }
  }
  if (p.length > 1 && /\/$/.test(p)) { p = p.substring(0, p.length - 1); }
  return p;
};

EasyFTP.prototype.waitConnect = function (cb) {
  var self = this;
  if (this.isLoginFail || this.waitCount >= 50) {
    this.close();
    return;
  }
  if (!this.isConnect) {
    this.waitCount++;
    setTimeout(function () {
      self.waitConnect(cb);
    }, 500);
  } else {
    this.waitCount = 0;
    cb();
  }
};

EasyFTP.prototype.pwd = function (cb) {
  var self = this;
  if (!this.isConnect) {
    this.waitConnect(function () {
      self.pwd(cb);
    });
  } else {
    switch (this.config.type) {
    case 'sftp':

      break;
    case 'ftp':
      this.client.raw.pwd(function (err, data) {
        if (!err && data) {
          var idx = data.text.indexOf("\"");
          data = data.text.substring(idx + 1, data.text.indexOf("\"", idx + 1));
        }
        cb(err, data);
      });
      break;
    }
  }
};

EasyFTP.prototype.cd = function (path, cb) {
  var self = this;
  if (!this.isConnect) {
    this.waitConnect(function () {
      self.cd(path, cb);
    });
  } else {
    path = this.getRealRemotePath(path);
    switch (this.config.type) {
    case 'sftp':
      self.client.sftp(function (err, sftp) {
        sftp.opendir(path, function (err, handle) {
          sftp.end();
          if (err) {
            if (cb) {
              cb(err);
            }
          } else {
            self.currentPath = path;
            if (cb) {
              cb(err, path);
            }
          }
        });
      });
      break;
    case 'ftp':
      this.client.raw.cwd(path, function (err, data) {
        if (cb) {
          cb(err, path);
        }
      });
      break;
    }
  }
};

EasyFTP.prototype.ls = function (path, cb) {
  var self = this;
  if (!this.isConnect) {
    this.waitConnect(function () {
      self.ls(path, cb);
    });
  } else {
    var p = this.getRealRemotePath(path);
    switch (this.config.type) {
    case 'sftp':
      self.client.sftp(function (err, sftp) {
        sftp.readdir(p, function (err, list) {
          sftp.end();
          if (err) {
            if (cb) { cb(err); }
          } else {
            var i = 0;
            for (i = 0; i < list.length; i++) {
              list[i].name = list[i].filename;
              list[i].date = new Date((list[i].attrs.mtime || list[i].attrs.atime) * 1000);
              list[i].size = list[i].attrs.size;
              list[i].type = list[i].longname.indexOf("d") === 0 ? 'd' : 'f';
            }
            if (cb) { cb(err, list); }
          }
        });
      });
      break;
    case 'ftp':
      if (this.isPasv) {
        this.client.list(p, function (err, data) {
          if (!err) {
            if (cb) { cb(err, parsePasvList(data)); }
          } else if (cb) {
            cb(err);
          }
        });
      } else {
        this.client.ls(p, function (err, list) {
          if (!err) {
            var i = 0,
                len = list.length;
            for (i = 0; i < len; i++) {
              list[i].date = new Date(list[i].time);
              list[i].type = list[i].type === 1 ? 'd' : 'f';
            }
            if (cb) { cb(err, list); }
          } else if (cb) {
            cb(err);
          }
        });
      }
      break;
    }
  }
};

EasyFTP.prototype.exist = function (path, cb) {
  var self = this;
  if (!this.isConnect) {
    this.waitConnect(function () {
      self.exist(path, cb);
    });
  } else {
    var cwd = this.currentPath;
    this.cd(path, function (err) {
      if (!err) {
        self.cd(cwd, function () {
          if (cb) { cb(true); }
        });
      } else {
        var parentPath = FileUtil.getParentPath(path);
        var fileName = FileUtil.getFileName(path);
        self.ls(parentPath, function (err, list) {
          self.cd(cwd, function () {
            if (err) {
              cb(false);
            } else {
              var exist = false,
                  i = 0;
              for (i = 0; i < list.length; i++) {
                if (list[i].name === fileName) {
                  exist = true;
                  break;
                }
              }
              cb(exist);
            }
          });
        });
      }
    });
  }
};

EasyFTP.prototype.download = function (remotePath, localPath, cb) {
  var self = this;

  console.log(remotePath, localPath);
  if (!this.isConnect) {
    this.waitConnect(function () {
      self.download(localPath, remotePath, cb);
    });
  } else {
    switch (this.config.type) {
    case 'sftp':
      self.client.sftp(function (err, sftp) {
        sftp.fastGet(remotePath, localPath, {concurrency: 1}, function (err) {
          sftp.end();
          if (err) {
            cb(err);
          } else {
            self.emit("download", localPath);
            cb();
          }
        });
      });
      break;
    case 'ftp':
      self.client.get(remotePath, localPath, function (err) {
        if (!err) {
          self.emit("download", localPath);
        }
        if (cb) {
          cb(err);
        }
      });
      break;
    }
  }
};

/*


EasyFTP.prototype.upload = function (localPath, remotePath, cb, isRecursive) {
  var self = this;

  function bodyDir(localPath, parent, cwd) {
    var list = FileUtil.lsSync(localPath);
    loop(list, function (i, value, next) {
      //console.log("bodyDir start : ", localPath + "/" + value, parent + "/" + value);
      self.upload(localPath + "/" + value, parent + "/" + value, function (err) {
        //console.log("bodyDir end : ", localPath + "/" + value, parent + "/" + value, err);
        next(err);
      }, true);
    }, function (err) {
      self.cd(cwd, function () {
        if (cb) { cb(err); }
      });
    });
  }

  function uploadFile(localPath, remotePath, cwd) {
    if (self.isFTP) {
      self.client.upload(localPath, remotePath, function (err) {
        if (!err) { self.emit("upload", remotePath); }
        self.cd(cwd, function () {
          if (cb) { cb(err); }
        });
      });
    } else {
      self.client.sftp(function (err, sftp) {
        sftp.fastPut(localPath, remotePath, {concurrency: 1}, function (err) {
          sftp.end();
          if (!err) { self.emit("upload", remotePath); }
          self.cd(cwd, function () {
            if (cb) { cb(err); }
          });
        });
      });
    }
  }

  if (!this.isConnect) {
    this.waitConnect(function () {
      self.upload(localPath, remotePath, cb, isRecursive);
    });
  } else {
    var cwd = this.currentPath;
    if (localPath instanceof Array) {
      if (typeof remotePath === 'function') {
        cb = remotePath;
        remotePath = null;
      }
      loop(localPath, function (i, value, next) {
        var local = value;
        var remote = remotePath;
        if (typeof value === 'object') {
          local = value.local;
          remote = value.remote;
        }
        self.upload(local, remote, function (err) {
          next(err);
        });
      }, function (err) {
        self.cd(cwd, function () {
          if (cb) { cb(err); }
        });
      });
      return;
    }
    localPath = FileUtil.replaceCorrectPath(localPath);
    if (/\/\*{1,2}$/.test(localPath)) {
      isRecursive = true;
      localPath = localPath.replace(/\/\*{1,2}$/, '');
    }
    remotePath = this.getRealRemotePath(remotePath);
    if (FileUtil.isDirSync(localPath)) {
      var parent = FileUtil.replaceCorrectPath(remotePath + (isRecursive ? "" : "/" + FileUtil.getFileName(localPath)));
      this.cd(parent, function (err) {
        if (err) {
          self.mkdir(parent, function (err) {
            //console.log("mkdir : ", parent, err);
            if (err) {
              self.cd(cwd, function () {
                if (cb) { cb(err); }
              });
            } else {
              self.emit("upload", parent);
              bodyDir(localPath, parent, cwd);
            }
          });
        } else {
          bodyDir(localPath, parent, cwd);
        }
      });
    } else {
      if (!isRecursive) {
        this.cd(remotePath, function (err) {
          if (!err) {
            remotePath = FileUtil.replaceCorrectPath(remotePath + "/" + FileUtil.getFileName(localPath));
          }
          var parent = FileUtil.getParentPath(remotePath);
          self.cd(parent, function (err) {
            if (err) {
              self.mkdir(parent, function (err) {
                if (err) {
                  self.cd(cwd, function () {
                    if (cb) { cb(err); }
                  });
                } else {
                  self.emit("upload", parent);
                  uploadFile(localPath, remotePath, cwd);
                }
              });
            } else {
              uploadFile(localPath, remotePath, cwd);
            }
          });
        });
      } else {
        uploadFile(localPath, remotePath, cwd);
      }
    }
  }
};



EasyFTP.prototype.mkdir = function (path, cb) {
  var self = this;
  if (!this.isConnect) {
    this.waitConnect(function () {
      self.mkdir(path, cb);
    });
  } else {
    var p = this.getRealRemotePath(path);
    if (this.isFTP) {
      this.client.mkdir(p, function (err) {
        if (cb) { cb(err); }
      });
    } else {
      this.client.exec('mkdir -p "' + p + '"', function (err, stream) {
        if (cb) { cb(err); }
      });
    }
  }
};

EasyFTP.prototype.rm = function (path, cb) {
  var self = this;
  if (!this.isConnect) {
    this.waitConnect(function () {
      self.rm(path, cb);
    });
  } else {
    var p = this.getRealRemotePath(path);
    if (this.isFTP) {
      this.client.rm(p, function (err) {
        if (cb) { cb(err); }
      });
    } else {
      this.client.exec('rm -rf "' + p + '"', function (err, stream) {
        if (cb) { cb(err); }
      });
    }
  }
};

EasyFTP.prototype.mv = function (oldPath, newPath, cb) {
  var self = this;
  if (!this.isConnect) {
    this.waitConnect(function () {
      self.mv(oldPath, newPath, cb);
    });
  } else {
    var op = this.getRealRemotePath(oldPath);
    var np = this.getRealRemotePath(newPath);
    if (this.isFTP) {
      this.client.mv(op, np, function (err, newPath) {
        if (cb) { cb(err, np); }
      });
    } else {
      self.client.sftp(function (err, sftp) {
        sftp.rename(op, np, function (err) {
          sftp.end();
          if (cb) { cb(err, np); }
        });
      });
    }
  }
};


*/

module.exports = EasyFTP;